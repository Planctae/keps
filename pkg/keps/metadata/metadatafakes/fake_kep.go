// Code generated by counterfeiter. DO NOT EDIT.
package metadatafakes

import (
	sync "sync"
	time "time"

	metadata "github.com/calebamiles/keps/pkg/keps/metadata"
	states "github.com/calebamiles/keps/pkg/keps/states"
)

type FakeKEP struct {
	AffectedSubprojectsStub        func() []string
	affectedSubprojectsMutex       sync.RWMutex
	affectedSubprojectsArgsForCall []struct {
	}
	affectedSubprojectsReturns struct {
		result1 []string
	}
	affectedSubprojectsReturnsOnCall map[int]struct {
		result1 []string
	}
	ApproversStub        func() []string
	approversMutex       sync.RWMutex
	approversArgsForCall []struct {
	}
	approversReturns struct {
		result1 []string
	}
	approversReturnsOnCall map[int]struct {
		result1 []string
	}
	AuthorsStub        func() []string
	authorsMutex       sync.RWMutex
	authorsArgsForCall []struct {
	}
	authorsReturns struct {
		result1 []string
	}
	authorsReturnsOnCall map[int]struct {
		result1 []string
	}
	ContentDirStub        func() string
	contentDirMutex       sync.RWMutex
	contentDirArgsForCall []struct {
	}
	contentDirReturns struct {
		result1 string
	}
	contentDirReturnsOnCall map[int]struct {
		result1 string
	}
	DevelopmentThemesStub        func() []string
	developmentThemesMutex       sync.RWMutex
	developmentThemesArgsForCall []struct {
	}
	developmentThemesReturns struct {
		result1 []string
	}
	developmentThemesReturnsOnCall map[int]struct {
		result1 []string
	}
	EditorsStub        func() []string
	editorsMutex       sync.RWMutex
	editorsArgsForCall []struct {
	}
	editorsReturns struct {
		result1 []string
	}
	editorsReturnsOnCall map[int]struct {
		result1 []string
	}
	KubernetesWideStub        func() bool
	kubernetesWideMutex       sync.RWMutex
	kubernetesWideArgsForCall []struct {
	}
	kubernetesWideReturns struct {
		result1 bool
	}
	kubernetesWideReturnsOnCall map[int]struct {
		result1 bool
	}
	LastUpdatedStub        func() time.Time
	lastUpdatedMutex       sync.RWMutex
	lastUpdatedArgsForCall []struct {
	}
	lastUpdatedReturns struct {
		result1 time.Time
	}
	lastUpdatedReturnsOnCall map[int]struct {
		result1 time.Time
	}
	NumberStub        func() int
	numberMutex       sync.RWMutex
	numberArgsForCall []struct {
	}
	numberReturns struct {
		result1 int
	}
	numberReturnsOnCall map[int]struct {
		result1 int
	}
	OwningSIGStub        func() string
	owningSIGMutex       sync.RWMutex
	owningSIGArgsForCall []struct {
	}
	owningSIGReturns struct {
		result1 string
	}
	owningSIGReturnsOnCall map[int]struct {
		result1 string
	}
	ParticpiatingSIGsStub        func() []string
	particpiatingSIGsMutex       sync.RWMutex
	particpiatingSIGsArgsForCall []struct {
	}
	particpiatingSIGsReturns struct {
		result1 []string
	}
	particpiatingSIGsReturnsOnCall map[int]struct {
		result1 []string
	}
	PersistStub        func() error
	persistMutex       sync.RWMutex
	persistArgsForCall []struct {
	}
	persistReturns struct {
		result1 error
	}
	persistReturnsOnCall map[int]struct {
		result1 error
	}
	ReplacesStub        func() string
	replacesMutex       sync.RWMutex
	replacesArgsForCall []struct {
	}
	replacesReturns struct {
		result1 string
	}
	replacesReturnsOnCall map[int]struct {
		result1 string
	}
	ReviewersStub        func() []string
	reviewersMutex       sync.RWMutex
	reviewersArgsForCall []struct {
	}
	reviewersReturns struct {
		result1 []string
	}
	reviewersReturnsOnCall map[int]struct {
		result1 []string
	}
	SIGWideStub        func() bool
	sIGWideMutex       sync.RWMutex
	sIGWideArgsForCall []struct {
	}
	sIGWideReturns struct {
		result1 bool
	}
	sIGWideReturnsOnCall map[int]struct {
		result1 bool
	}
	StateStub        func() states.Name
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 states.Name
	}
	stateReturnsOnCall map[int]struct {
		result1 states.Name
	}
	TitleStub        func() string
	titleMutex       sync.RWMutex
	titleArgsForCall []struct {
	}
	titleReturns struct {
		result1 string
	}
	titleReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKEP) AffectedSubprojects() []string {
	fake.affectedSubprojectsMutex.Lock()
	ret, specificReturn := fake.affectedSubprojectsReturnsOnCall[len(fake.affectedSubprojectsArgsForCall)]
	fake.affectedSubprojectsArgsForCall = append(fake.affectedSubprojectsArgsForCall, struct {
	}{})
	fake.recordInvocation("AffectedSubprojects", []interface{}{})
	fake.affectedSubprojectsMutex.Unlock()
	if fake.AffectedSubprojectsStub != nil {
		return fake.AffectedSubprojectsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.affectedSubprojectsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) AffectedSubprojectsCallCount() int {
	fake.affectedSubprojectsMutex.RLock()
	defer fake.affectedSubprojectsMutex.RUnlock()
	return len(fake.affectedSubprojectsArgsForCall)
}

func (fake *FakeKEP) AffectedSubprojectsReturns(result1 []string) {
	fake.AffectedSubprojectsStub = nil
	fake.affectedSubprojectsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) AffectedSubprojectsReturnsOnCall(i int, result1 []string) {
	fake.AffectedSubprojectsStub = nil
	if fake.affectedSubprojectsReturnsOnCall == nil {
		fake.affectedSubprojectsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.affectedSubprojectsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Approvers() []string {
	fake.approversMutex.Lock()
	ret, specificReturn := fake.approversReturnsOnCall[len(fake.approversArgsForCall)]
	fake.approversArgsForCall = append(fake.approversArgsForCall, struct {
	}{})
	fake.recordInvocation("Approvers", []interface{}{})
	fake.approversMutex.Unlock()
	if fake.ApproversStub != nil {
		return fake.ApproversStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.approversReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ApproversCallCount() int {
	fake.approversMutex.RLock()
	defer fake.approversMutex.RUnlock()
	return len(fake.approversArgsForCall)
}

func (fake *FakeKEP) ApproversReturns(result1 []string) {
	fake.ApproversStub = nil
	fake.approversReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ApproversReturnsOnCall(i int, result1 []string) {
	fake.ApproversStub = nil
	if fake.approversReturnsOnCall == nil {
		fake.approversReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.approversReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Authors() []string {
	fake.authorsMutex.Lock()
	ret, specificReturn := fake.authorsReturnsOnCall[len(fake.authorsArgsForCall)]
	fake.authorsArgsForCall = append(fake.authorsArgsForCall, struct {
	}{})
	fake.recordInvocation("Authors", []interface{}{})
	fake.authorsMutex.Unlock()
	if fake.AuthorsStub != nil {
		return fake.AuthorsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authorsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) AuthorsCallCount() int {
	fake.authorsMutex.RLock()
	defer fake.authorsMutex.RUnlock()
	return len(fake.authorsArgsForCall)
}

func (fake *FakeKEP) AuthorsReturns(result1 []string) {
	fake.AuthorsStub = nil
	fake.authorsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) AuthorsReturnsOnCall(i int, result1 []string) {
	fake.AuthorsStub = nil
	if fake.authorsReturnsOnCall == nil {
		fake.authorsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.authorsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ContentDir() string {
	fake.contentDirMutex.Lock()
	ret, specificReturn := fake.contentDirReturnsOnCall[len(fake.contentDirArgsForCall)]
	fake.contentDirArgsForCall = append(fake.contentDirArgsForCall, struct {
	}{})
	fake.recordInvocation("ContentDir", []interface{}{})
	fake.contentDirMutex.Unlock()
	if fake.ContentDirStub != nil {
		return fake.ContentDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.contentDirReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ContentDirCallCount() int {
	fake.contentDirMutex.RLock()
	defer fake.contentDirMutex.RUnlock()
	return len(fake.contentDirArgsForCall)
}

func (fake *FakeKEP) ContentDirReturns(result1 string) {
	fake.ContentDirStub = nil
	fake.contentDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) ContentDirReturnsOnCall(i int, result1 string) {
	fake.ContentDirStub = nil
	if fake.contentDirReturnsOnCall == nil {
		fake.contentDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.contentDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) DevelopmentThemes() []string {
	fake.developmentThemesMutex.Lock()
	ret, specificReturn := fake.developmentThemesReturnsOnCall[len(fake.developmentThemesArgsForCall)]
	fake.developmentThemesArgsForCall = append(fake.developmentThemesArgsForCall, struct {
	}{})
	fake.recordInvocation("DevelopmentThemes", []interface{}{})
	fake.developmentThemesMutex.Unlock()
	if fake.DevelopmentThemesStub != nil {
		return fake.DevelopmentThemesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.developmentThemesReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) DevelopmentThemesCallCount() int {
	fake.developmentThemesMutex.RLock()
	defer fake.developmentThemesMutex.RUnlock()
	return len(fake.developmentThemesArgsForCall)
}

func (fake *FakeKEP) DevelopmentThemesReturns(result1 []string) {
	fake.DevelopmentThemesStub = nil
	fake.developmentThemesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) DevelopmentThemesReturnsOnCall(i int, result1 []string) {
	fake.DevelopmentThemesStub = nil
	if fake.developmentThemesReturnsOnCall == nil {
		fake.developmentThemesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.developmentThemesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Editors() []string {
	fake.editorsMutex.Lock()
	ret, specificReturn := fake.editorsReturnsOnCall[len(fake.editorsArgsForCall)]
	fake.editorsArgsForCall = append(fake.editorsArgsForCall, struct {
	}{})
	fake.recordInvocation("Editors", []interface{}{})
	fake.editorsMutex.Unlock()
	if fake.EditorsStub != nil {
		return fake.EditorsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.editorsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) EditorsCallCount() int {
	fake.editorsMutex.RLock()
	defer fake.editorsMutex.RUnlock()
	return len(fake.editorsArgsForCall)
}

func (fake *FakeKEP) EditorsReturns(result1 []string) {
	fake.EditorsStub = nil
	fake.editorsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) EditorsReturnsOnCall(i int, result1 []string) {
	fake.EditorsStub = nil
	if fake.editorsReturnsOnCall == nil {
		fake.editorsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.editorsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) KubernetesWide() bool {
	fake.kubernetesWideMutex.Lock()
	ret, specificReturn := fake.kubernetesWideReturnsOnCall[len(fake.kubernetesWideArgsForCall)]
	fake.kubernetesWideArgsForCall = append(fake.kubernetesWideArgsForCall, struct {
	}{})
	fake.recordInvocation("KubernetesWide", []interface{}{})
	fake.kubernetesWideMutex.Unlock()
	if fake.KubernetesWideStub != nil {
		return fake.KubernetesWideStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.kubernetesWideReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) KubernetesWideCallCount() int {
	fake.kubernetesWideMutex.RLock()
	defer fake.kubernetesWideMutex.RUnlock()
	return len(fake.kubernetesWideArgsForCall)
}

func (fake *FakeKEP) KubernetesWideReturns(result1 bool) {
	fake.KubernetesWideStub = nil
	fake.kubernetesWideReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) KubernetesWideReturnsOnCall(i int, result1 bool) {
	fake.KubernetesWideStub = nil
	if fake.kubernetesWideReturnsOnCall == nil {
		fake.kubernetesWideReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.kubernetesWideReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) LastUpdated() time.Time {
	fake.lastUpdatedMutex.Lock()
	ret, specificReturn := fake.lastUpdatedReturnsOnCall[len(fake.lastUpdatedArgsForCall)]
	fake.lastUpdatedArgsForCall = append(fake.lastUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("LastUpdated", []interface{}{})
	fake.lastUpdatedMutex.Unlock()
	if fake.LastUpdatedStub != nil {
		return fake.LastUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lastUpdatedReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) LastUpdatedCallCount() int {
	fake.lastUpdatedMutex.RLock()
	defer fake.lastUpdatedMutex.RUnlock()
	return len(fake.lastUpdatedArgsForCall)
}

func (fake *FakeKEP) LastUpdatedReturns(result1 time.Time) {
	fake.LastUpdatedStub = nil
	fake.lastUpdatedReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeKEP) LastUpdatedReturnsOnCall(i int, result1 time.Time) {
	fake.LastUpdatedStub = nil
	if fake.lastUpdatedReturnsOnCall == nil {
		fake.lastUpdatedReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.lastUpdatedReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeKEP) Number() int {
	fake.numberMutex.Lock()
	ret, specificReturn := fake.numberReturnsOnCall[len(fake.numberArgsForCall)]
	fake.numberArgsForCall = append(fake.numberArgsForCall, struct {
	}{})
	fake.recordInvocation("Number", []interface{}{})
	fake.numberMutex.Unlock()
	if fake.NumberStub != nil {
		return fake.NumberStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.numberReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) NumberCallCount() int {
	fake.numberMutex.RLock()
	defer fake.numberMutex.RUnlock()
	return len(fake.numberArgsForCall)
}

func (fake *FakeKEP) NumberReturns(result1 int) {
	fake.NumberStub = nil
	fake.numberReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeKEP) NumberReturnsOnCall(i int, result1 int) {
	fake.NumberStub = nil
	if fake.numberReturnsOnCall == nil {
		fake.numberReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numberReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeKEP) OwningSIG() string {
	fake.owningSIGMutex.Lock()
	ret, specificReturn := fake.owningSIGReturnsOnCall[len(fake.owningSIGArgsForCall)]
	fake.owningSIGArgsForCall = append(fake.owningSIGArgsForCall, struct {
	}{})
	fake.recordInvocation("OwningSIG", []interface{}{})
	fake.owningSIGMutex.Unlock()
	if fake.OwningSIGStub != nil {
		return fake.OwningSIGStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.owningSIGReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) OwningSIGCallCount() int {
	fake.owningSIGMutex.RLock()
	defer fake.owningSIGMutex.RUnlock()
	return len(fake.owningSIGArgsForCall)
}

func (fake *FakeKEP) OwningSIGReturns(result1 string) {
	fake.OwningSIGStub = nil
	fake.owningSIGReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) OwningSIGReturnsOnCall(i int, result1 string) {
	fake.OwningSIGStub = nil
	if fake.owningSIGReturnsOnCall == nil {
		fake.owningSIGReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.owningSIGReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) ParticpiatingSIGs() []string {
	fake.particpiatingSIGsMutex.Lock()
	ret, specificReturn := fake.particpiatingSIGsReturnsOnCall[len(fake.particpiatingSIGsArgsForCall)]
	fake.particpiatingSIGsArgsForCall = append(fake.particpiatingSIGsArgsForCall, struct {
	}{})
	fake.recordInvocation("ParticpiatingSIGs", []interface{}{})
	fake.particpiatingSIGsMutex.Unlock()
	if fake.ParticpiatingSIGsStub != nil {
		return fake.ParticpiatingSIGsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.particpiatingSIGsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ParticpiatingSIGsCallCount() int {
	fake.particpiatingSIGsMutex.RLock()
	defer fake.particpiatingSIGsMutex.RUnlock()
	return len(fake.particpiatingSIGsArgsForCall)
}

func (fake *FakeKEP) ParticpiatingSIGsReturns(result1 []string) {
	fake.ParticpiatingSIGsStub = nil
	fake.particpiatingSIGsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ParticpiatingSIGsReturnsOnCall(i int, result1 []string) {
	fake.ParticpiatingSIGsStub = nil
	if fake.particpiatingSIGsReturnsOnCall == nil {
		fake.particpiatingSIGsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.particpiatingSIGsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Persist() error {
	fake.persistMutex.Lock()
	ret, specificReturn := fake.persistReturnsOnCall[len(fake.persistArgsForCall)]
	fake.persistArgsForCall = append(fake.persistArgsForCall, struct {
	}{})
	fake.recordInvocation("Persist", []interface{}{})
	fake.persistMutex.Unlock()
	if fake.PersistStub != nil {
		return fake.PersistStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.persistReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) PersistCallCount() int {
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	return len(fake.persistArgsForCall)
}

func (fake *FakeKEP) PersistReturns(result1 error) {
	fake.PersistStub = nil
	fake.persistReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKEP) PersistReturnsOnCall(i int, result1 error) {
	fake.PersistStub = nil
	if fake.persistReturnsOnCall == nil {
		fake.persistReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.persistReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKEP) Replaces() string {
	fake.replacesMutex.Lock()
	ret, specificReturn := fake.replacesReturnsOnCall[len(fake.replacesArgsForCall)]
	fake.replacesArgsForCall = append(fake.replacesArgsForCall, struct {
	}{})
	fake.recordInvocation("Replaces", []interface{}{})
	fake.replacesMutex.Unlock()
	if fake.ReplacesStub != nil {
		return fake.ReplacesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.replacesReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ReplacesCallCount() int {
	fake.replacesMutex.RLock()
	defer fake.replacesMutex.RUnlock()
	return len(fake.replacesArgsForCall)
}

func (fake *FakeKEP) ReplacesReturns(result1 string) {
	fake.ReplacesStub = nil
	fake.replacesReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) ReplacesReturnsOnCall(i int, result1 string) {
	fake.ReplacesStub = nil
	if fake.replacesReturnsOnCall == nil {
		fake.replacesReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.replacesReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) Reviewers() []string {
	fake.reviewersMutex.Lock()
	ret, specificReturn := fake.reviewersReturnsOnCall[len(fake.reviewersArgsForCall)]
	fake.reviewersArgsForCall = append(fake.reviewersArgsForCall, struct {
	}{})
	fake.recordInvocation("Reviewers", []interface{}{})
	fake.reviewersMutex.Unlock()
	if fake.ReviewersStub != nil {
		return fake.ReviewersStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.reviewersReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ReviewersCallCount() int {
	fake.reviewersMutex.RLock()
	defer fake.reviewersMutex.RUnlock()
	return len(fake.reviewersArgsForCall)
}

func (fake *FakeKEP) ReviewersReturns(result1 []string) {
	fake.ReviewersStub = nil
	fake.reviewersReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ReviewersReturnsOnCall(i int, result1 []string) {
	fake.ReviewersStub = nil
	if fake.reviewersReturnsOnCall == nil {
		fake.reviewersReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.reviewersReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) SIGWide() bool {
	fake.sIGWideMutex.Lock()
	ret, specificReturn := fake.sIGWideReturnsOnCall[len(fake.sIGWideArgsForCall)]
	fake.sIGWideArgsForCall = append(fake.sIGWideArgsForCall, struct {
	}{})
	fake.recordInvocation("SIGWide", []interface{}{})
	fake.sIGWideMutex.Unlock()
	if fake.SIGWideStub != nil {
		return fake.SIGWideStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sIGWideReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) SIGWideCallCount() int {
	fake.sIGWideMutex.RLock()
	defer fake.sIGWideMutex.RUnlock()
	return len(fake.sIGWideArgsForCall)
}

func (fake *FakeKEP) SIGWideReturns(result1 bool) {
	fake.SIGWideStub = nil
	fake.sIGWideReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) SIGWideReturnsOnCall(i int, result1 bool) {
	fake.SIGWideStub = nil
	if fake.sIGWideReturnsOnCall == nil {
		fake.sIGWideReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.sIGWideReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) State() states.Name {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if fake.StateStub != nil {
		return fake.StateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stateReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeKEP) StateReturns(result1 states.Name) {
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 states.Name
	}{result1}
}

func (fake *FakeKEP) StateReturnsOnCall(i int, result1 states.Name) {
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 states.Name
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 states.Name
	}{result1}
}

func (fake *FakeKEP) Title() string {
	fake.titleMutex.Lock()
	ret, specificReturn := fake.titleReturnsOnCall[len(fake.titleArgsForCall)]
	fake.titleArgsForCall = append(fake.titleArgsForCall, struct {
	}{})
	fake.recordInvocation("Title", []interface{}{})
	fake.titleMutex.Unlock()
	if fake.TitleStub != nil {
		return fake.TitleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.titleReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) TitleCallCount() int {
	fake.titleMutex.RLock()
	defer fake.titleMutex.RUnlock()
	return len(fake.titleArgsForCall)
}

func (fake *FakeKEP) TitleReturns(result1 string) {
	fake.TitleStub = nil
	fake.titleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) TitleReturnsOnCall(i int, result1 string) {
	fake.TitleStub = nil
	if fake.titleReturnsOnCall == nil {
		fake.titleReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.titleReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.affectedSubprojectsMutex.RLock()
	defer fake.affectedSubprojectsMutex.RUnlock()
	fake.approversMutex.RLock()
	defer fake.approversMutex.RUnlock()
	fake.authorsMutex.RLock()
	defer fake.authorsMutex.RUnlock()
	fake.contentDirMutex.RLock()
	defer fake.contentDirMutex.RUnlock()
	fake.developmentThemesMutex.RLock()
	defer fake.developmentThemesMutex.RUnlock()
	fake.editorsMutex.RLock()
	defer fake.editorsMutex.RUnlock()
	fake.kubernetesWideMutex.RLock()
	defer fake.kubernetesWideMutex.RUnlock()
	fake.lastUpdatedMutex.RLock()
	defer fake.lastUpdatedMutex.RUnlock()
	fake.numberMutex.RLock()
	defer fake.numberMutex.RUnlock()
	fake.owningSIGMutex.RLock()
	defer fake.owningSIGMutex.RUnlock()
	fake.particpiatingSIGsMutex.RLock()
	defer fake.particpiatingSIGsMutex.RUnlock()
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	fake.replacesMutex.RLock()
	defer fake.replacesMutex.RUnlock()
	fake.reviewersMutex.RLock()
	defer fake.reviewersMutex.RUnlock()
	fake.sIGWideMutex.RLock()
	defer fake.sIGWideMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.titleMutex.RLock()
	defer fake.titleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKEP) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metadata.KEP = new(FakeKEP)
