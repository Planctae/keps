// Code generated by counterfeiter. DO NOT EDIT.
package metadatafakes

import (
	sync "sync"
	time "time"

	metadata "github.com/calebamiles/keps/pkg/keps/metadata"
	states "github.com/calebamiles/keps/pkg/keps/states"
)

type FakeKEP struct {
	AddApproversStub        func([]string)
	addApproversMutex       sync.RWMutex
	addApproversArgsForCall []struct {
		arg1 []string
	}
	AddReviewersStub        func([]string)
	addReviewersMutex       sync.RWMutex
	addReviewersArgsForCall []struct {
		arg1 []string
	}
	AddSectionsStub        func([]string)
	addSectionsMutex       sync.RWMutex
	addSectionsArgsForCall []struct {
		arg1 []string
	}
	AffectedSubprojectsStub        func() []string
	affectedSubprojectsMutex       sync.RWMutex
	affectedSubprojectsArgsForCall []struct {
	}
	affectedSubprojectsReturns struct {
		result1 []string
	}
	affectedSubprojectsReturnsOnCall map[int]struct {
		result1 []string
	}
	ApproversStub        func() []string
	approversMutex       sync.RWMutex
	approversArgsForCall []struct {
	}
	approversReturns struct {
		result1 []string
	}
	approversReturnsOnCall map[int]struct {
		result1 []string
	}
	AuthorsStub        func() []string
	authorsMutex       sync.RWMutex
	authorsArgsForCall []struct {
	}
	authorsReturns struct {
		result1 []string
	}
	authorsReturnsOnCall map[int]struct {
		result1 []string
	}
	ContentDirStub        func() string
	contentDirMutex       sync.RWMutex
	contentDirArgsForCall []struct {
	}
	contentDirReturns struct {
		result1 string
	}
	contentDirReturnsOnCall map[int]struct {
		result1 string
	}
	CreatedStub        func() time.Time
	createdMutex       sync.RWMutex
	createdArgsForCall []struct {
	}
	createdReturns struct {
		result1 time.Time
	}
	createdReturnsOnCall map[int]struct {
		result1 time.Time
	}
	DevelopmentThemesStub        func() []string
	developmentThemesMutex       sync.RWMutex
	developmentThemesArgsForCall []struct {
	}
	developmentThemesReturns struct {
		result1 []string
	}
	developmentThemesReturnsOnCall map[int]struct {
		result1 []string
	}
	EditorsStub        func() []string
	editorsMutex       sync.RWMutex
	editorsArgsForCall []struct {
	}
	editorsReturns struct {
		result1 []string
	}
	editorsReturnsOnCall map[int]struct {
		result1 []string
	}
	KubernetesWideStub        func() bool
	kubernetesWideMutex       sync.RWMutex
	kubernetesWideArgsForCall []struct {
	}
	kubernetesWideReturns struct {
		result1 bool
	}
	kubernetesWideReturnsOnCall map[int]struct {
		result1 bool
	}
	LastUpdatedStub        func() time.Time
	lastUpdatedMutex       sync.RWMutex
	lastUpdatedArgsForCall []struct {
	}
	lastUpdatedReturns struct {
		result1 time.Time
	}
	lastUpdatedReturnsOnCall map[int]struct {
		result1 time.Time
	}
	OwningSIGStub        func() string
	owningSIGMutex       sync.RWMutex
	owningSIGArgsForCall []struct {
	}
	owningSIGReturns struct {
		result1 string
	}
	owningSIGReturnsOnCall map[int]struct {
		result1 string
	}
	ParticipatingSIGsStub        func() []string
	participatingSIGsMutex       sync.RWMutex
	participatingSIGsArgsForCall []struct {
	}
	participatingSIGsReturns struct {
		result1 []string
	}
	participatingSIGsReturnsOnCall map[int]struct {
		result1 []string
	}
	PersistStub        func() error
	persistMutex       sync.RWMutex
	persistArgsForCall []struct {
	}
	persistReturns struct {
		result1 error
	}
	persistReturnsOnCall map[int]struct {
		result1 error
	}
	ReplacesStub        func() []string
	replacesMutex       sync.RWMutex
	replacesArgsForCall []struct {
	}
	replacesReturns struct {
		result1 []string
	}
	replacesReturnsOnCall map[int]struct {
		result1 []string
	}
	ReviewersStub        func() []string
	reviewersMutex       sync.RWMutex
	reviewersArgsForCall []struct {
	}
	reviewersReturns struct {
		result1 []string
	}
	reviewersReturnsOnCall map[int]struct {
		result1 []string
	}
	SIGWideStub        func() bool
	sIGWideMutex       sync.RWMutex
	sIGWideArgsForCall []struct {
	}
	sIGWideReturns struct {
		result1 bool
	}
	sIGWideReturnsOnCall map[int]struct {
		result1 bool
	}
	SectionsStub        func() []string
	sectionsMutex       sync.RWMutex
	sectionsArgsForCall []struct {
	}
	sectionsReturns struct {
		result1 []string
	}
	sectionsReturnsOnCall map[int]struct {
		result1 []string
	}
	SetStateStub        func(states.Name)
	setStateMutex       sync.RWMutex
	setStateArgsForCall []struct {
		arg1 states.Name
	}
	ShortIDStub        func() int
	shortIDMutex       sync.RWMutex
	shortIDArgsForCall []struct {
	}
	shortIDReturns struct {
		result1 int
	}
	shortIDReturnsOnCall map[int]struct {
		result1 int
	}
	StateStub        func() states.Name
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 states.Name
	}
	stateReturnsOnCall map[int]struct {
		result1 states.Name
	}
	SupersededByStub        func() []string
	supersededByMutex       sync.RWMutex
	supersededByArgsForCall []struct {
	}
	supersededByReturns struct {
		result1 []string
	}
	supersededByReturnsOnCall map[int]struct {
		result1 []string
	}
	TitleStub        func() string
	titleMutex       sync.RWMutex
	titleArgsForCall []struct {
	}
	titleReturns struct {
		result1 string
	}
	titleReturnsOnCall map[int]struct {
		result1 string
	}
	UniqueIDStub        func() string
	uniqueIDMutex       sync.RWMutex
	uniqueIDArgsForCall []struct {
	}
	uniqueIDReturns struct {
		result1 string
	}
	uniqueIDReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKEP) AddApprovers(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.addApproversMutex.Lock()
	fake.addApproversArgsForCall = append(fake.addApproversArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("AddApprovers", []interface{}{arg1Copy})
	fake.addApproversMutex.Unlock()
	if fake.AddApproversStub != nil {
		fake.AddApproversStub(arg1)
	}
}

func (fake *FakeKEP) AddApproversCallCount() int {
	fake.addApproversMutex.RLock()
	defer fake.addApproversMutex.RUnlock()
	return len(fake.addApproversArgsForCall)
}

func (fake *FakeKEP) AddApproversArgsForCall(i int) []string {
	fake.addApproversMutex.RLock()
	defer fake.addApproversMutex.RUnlock()
	argsForCall := fake.addApproversArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKEP) AddReviewers(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.addReviewersMutex.Lock()
	fake.addReviewersArgsForCall = append(fake.addReviewersArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("AddReviewers", []interface{}{arg1Copy})
	fake.addReviewersMutex.Unlock()
	if fake.AddReviewersStub != nil {
		fake.AddReviewersStub(arg1)
	}
}

func (fake *FakeKEP) AddReviewersCallCount() int {
	fake.addReviewersMutex.RLock()
	defer fake.addReviewersMutex.RUnlock()
	return len(fake.addReviewersArgsForCall)
}

func (fake *FakeKEP) AddReviewersArgsForCall(i int) []string {
	fake.addReviewersMutex.RLock()
	defer fake.addReviewersMutex.RUnlock()
	argsForCall := fake.addReviewersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKEP) AddSections(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.addSectionsMutex.Lock()
	fake.addSectionsArgsForCall = append(fake.addSectionsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("AddSections", []interface{}{arg1Copy})
	fake.addSectionsMutex.Unlock()
	if fake.AddSectionsStub != nil {
		fake.AddSectionsStub(arg1)
	}
}

func (fake *FakeKEP) AddSectionsCallCount() int {
	fake.addSectionsMutex.RLock()
	defer fake.addSectionsMutex.RUnlock()
	return len(fake.addSectionsArgsForCall)
}

func (fake *FakeKEP) AddSectionsArgsForCall(i int) []string {
	fake.addSectionsMutex.RLock()
	defer fake.addSectionsMutex.RUnlock()
	argsForCall := fake.addSectionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKEP) AffectedSubprojects() []string {
	fake.affectedSubprojectsMutex.Lock()
	ret, specificReturn := fake.affectedSubprojectsReturnsOnCall[len(fake.affectedSubprojectsArgsForCall)]
	fake.affectedSubprojectsArgsForCall = append(fake.affectedSubprojectsArgsForCall, struct {
	}{})
	fake.recordInvocation("AffectedSubprojects", []interface{}{})
	fake.affectedSubprojectsMutex.Unlock()
	if fake.AffectedSubprojectsStub != nil {
		return fake.AffectedSubprojectsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.affectedSubprojectsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) AffectedSubprojectsCallCount() int {
	fake.affectedSubprojectsMutex.RLock()
	defer fake.affectedSubprojectsMutex.RUnlock()
	return len(fake.affectedSubprojectsArgsForCall)
}

func (fake *FakeKEP) AffectedSubprojectsReturns(result1 []string) {
	fake.AffectedSubprojectsStub = nil
	fake.affectedSubprojectsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) AffectedSubprojectsReturnsOnCall(i int, result1 []string) {
	fake.AffectedSubprojectsStub = nil
	if fake.affectedSubprojectsReturnsOnCall == nil {
		fake.affectedSubprojectsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.affectedSubprojectsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Approvers() []string {
	fake.approversMutex.Lock()
	ret, specificReturn := fake.approversReturnsOnCall[len(fake.approversArgsForCall)]
	fake.approversArgsForCall = append(fake.approversArgsForCall, struct {
	}{})
	fake.recordInvocation("Approvers", []interface{}{})
	fake.approversMutex.Unlock()
	if fake.ApproversStub != nil {
		return fake.ApproversStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.approversReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ApproversCallCount() int {
	fake.approversMutex.RLock()
	defer fake.approversMutex.RUnlock()
	return len(fake.approversArgsForCall)
}

func (fake *FakeKEP) ApproversReturns(result1 []string) {
	fake.ApproversStub = nil
	fake.approversReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ApproversReturnsOnCall(i int, result1 []string) {
	fake.ApproversStub = nil
	if fake.approversReturnsOnCall == nil {
		fake.approversReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.approversReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Authors() []string {
	fake.authorsMutex.Lock()
	ret, specificReturn := fake.authorsReturnsOnCall[len(fake.authorsArgsForCall)]
	fake.authorsArgsForCall = append(fake.authorsArgsForCall, struct {
	}{})
	fake.recordInvocation("Authors", []interface{}{})
	fake.authorsMutex.Unlock()
	if fake.AuthorsStub != nil {
		return fake.AuthorsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.authorsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) AuthorsCallCount() int {
	fake.authorsMutex.RLock()
	defer fake.authorsMutex.RUnlock()
	return len(fake.authorsArgsForCall)
}

func (fake *FakeKEP) AuthorsReturns(result1 []string) {
	fake.AuthorsStub = nil
	fake.authorsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) AuthorsReturnsOnCall(i int, result1 []string) {
	fake.AuthorsStub = nil
	if fake.authorsReturnsOnCall == nil {
		fake.authorsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.authorsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ContentDir() string {
	fake.contentDirMutex.Lock()
	ret, specificReturn := fake.contentDirReturnsOnCall[len(fake.contentDirArgsForCall)]
	fake.contentDirArgsForCall = append(fake.contentDirArgsForCall, struct {
	}{})
	fake.recordInvocation("ContentDir", []interface{}{})
	fake.contentDirMutex.Unlock()
	if fake.ContentDirStub != nil {
		return fake.ContentDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.contentDirReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ContentDirCallCount() int {
	fake.contentDirMutex.RLock()
	defer fake.contentDirMutex.RUnlock()
	return len(fake.contentDirArgsForCall)
}

func (fake *FakeKEP) ContentDirReturns(result1 string) {
	fake.ContentDirStub = nil
	fake.contentDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) ContentDirReturnsOnCall(i int, result1 string) {
	fake.ContentDirStub = nil
	if fake.contentDirReturnsOnCall == nil {
		fake.contentDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.contentDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) Created() time.Time {
	fake.createdMutex.Lock()
	ret, specificReturn := fake.createdReturnsOnCall[len(fake.createdArgsForCall)]
	fake.createdArgsForCall = append(fake.createdArgsForCall, struct {
	}{})
	fake.recordInvocation("Created", []interface{}{})
	fake.createdMutex.Unlock()
	if fake.CreatedStub != nil {
		return fake.CreatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createdReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) CreatedCallCount() int {
	fake.createdMutex.RLock()
	defer fake.createdMutex.RUnlock()
	return len(fake.createdArgsForCall)
}

func (fake *FakeKEP) CreatedReturns(result1 time.Time) {
	fake.CreatedStub = nil
	fake.createdReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeKEP) CreatedReturnsOnCall(i int, result1 time.Time) {
	fake.CreatedStub = nil
	if fake.createdReturnsOnCall == nil {
		fake.createdReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.createdReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeKEP) DevelopmentThemes() []string {
	fake.developmentThemesMutex.Lock()
	ret, specificReturn := fake.developmentThemesReturnsOnCall[len(fake.developmentThemesArgsForCall)]
	fake.developmentThemesArgsForCall = append(fake.developmentThemesArgsForCall, struct {
	}{})
	fake.recordInvocation("DevelopmentThemes", []interface{}{})
	fake.developmentThemesMutex.Unlock()
	if fake.DevelopmentThemesStub != nil {
		return fake.DevelopmentThemesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.developmentThemesReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) DevelopmentThemesCallCount() int {
	fake.developmentThemesMutex.RLock()
	defer fake.developmentThemesMutex.RUnlock()
	return len(fake.developmentThemesArgsForCall)
}

func (fake *FakeKEP) DevelopmentThemesReturns(result1 []string) {
	fake.DevelopmentThemesStub = nil
	fake.developmentThemesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) DevelopmentThemesReturnsOnCall(i int, result1 []string) {
	fake.DevelopmentThemesStub = nil
	if fake.developmentThemesReturnsOnCall == nil {
		fake.developmentThemesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.developmentThemesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Editors() []string {
	fake.editorsMutex.Lock()
	ret, specificReturn := fake.editorsReturnsOnCall[len(fake.editorsArgsForCall)]
	fake.editorsArgsForCall = append(fake.editorsArgsForCall, struct {
	}{})
	fake.recordInvocation("Editors", []interface{}{})
	fake.editorsMutex.Unlock()
	if fake.EditorsStub != nil {
		return fake.EditorsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.editorsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) EditorsCallCount() int {
	fake.editorsMutex.RLock()
	defer fake.editorsMutex.RUnlock()
	return len(fake.editorsArgsForCall)
}

func (fake *FakeKEP) EditorsReturns(result1 []string) {
	fake.EditorsStub = nil
	fake.editorsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) EditorsReturnsOnCall(i int, result1 []string) {
	fake.EditorsStub = nil
	if fake.editorsReturnsOnCall == nil {
		fake.editorsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.editorsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) KubernetesWide() bool {
	fake.kubernetesWideMutex.Lock()
	ret, specificReturn := fake.kubernetesWideReturnsOnCall[len(fake.kubernetesWideArgsForCall)]
	fake.kubernetesWideArgsForCall = append(fake.kubernetesWideArgsForCall, struct {
	}{})
	fake.recordInvocation("KubernetesWide", []interface{}{})
	fake.kubernetesWideMutex.Unlock()
	if fake.KubernetesWideStub != nil {
		return fake.KubernetesWideStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.kubernetesWideReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) KubernetesWideCallCount() int {
	fake.kubernetesWideMutex.RLock()
	defer fake.kubernetesWideMutex.RUnlock()
	return len(fake.kubernetesWideArgsForCall)
}

func (fake *FakeKEP) KubernetesWideReturns(result1 bool) {
	fake.KubernetesWideStub = nil
	fake.kubernetesWideReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) KubernetesWideReturnsOnCall(i int, result1 bool) {
	fake.KubernetesWideStub = nil
	if fake.kubernetesWideReturnsOnCall == nil {
		fake.kubernetesWideReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.kubernetesWideReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) LastUpdated() time.Time {
	fake.lastUpdatedMutex.Lock()
	ret, specificReturn := fake.lastUpdatedReturnsOnCall[len(fake.lastUpdatedArgsForCall)]
	fake.lastUpdatedArgsForCall = append(fake.lastUpdatedArgsForCall, struct {
	}{})
	fake.recordInvocation("LastUpdated", []interface{}{})
	fake.lastUpdatedMutex.Unlock()
	if fake.LastUpdatedStub != nil {
		return fake.LastUpdatedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lastUpdatedReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) LastUpdatedCallCount() int {
	fake.lastUpdatedMutex.RLock()
	defer fake.lastUpdatedMutex.RUnlock()
	return len(fake.lastUpdatedArgsForCall)
}

func (fake *FakeKEP) LastUpdatedReturns(result1 time.Time) {
	fake.LastUpdatedStub = nil
	fake.lastUpdatedReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeKEP) LastUpdatedReturnsOnCall(i int, result1 time.Time) {
	fake.LastUpdatedStub = nil
	if fake.lastUpdatedReturnsOnCall == nil {
		fake.lastUpdatedReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.lastUpdatedReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeKEP) OwningSIG() string {
	fake.owningSIGMutex.Lock()
	ret, specificReturn := fake.owningSIGReturnsOnCall[len(fake.owningSIGArgsForCall)]
	fake.owningSIGArgsForCall = append(fake.owningSIGArgsForCall, struct {
	}{})
	fake.recordInvocation("OwningSIG", []interface{}{})
	fake.owningSIGMutex.Unlock()
	if fake.OwningSIGStub != nil {
		return fake.OwningSIGStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.owningSIGReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) OwningSIGCallCount() int {
	fake.owningSIGMutex.RLock()
	defer fake.owningSIGMutex.RUnlock()
	return len(fake.owningSIGArgsForCall)
}

func (fake *FakeKEP) OwningSIGReturns(result1 string) {
	fake.OwningSIGStub = nil
	fake.owningSIGReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) OwningSIGReturnsOnCall(i int, result1 string) {
	fake.OwningSIGStub = nil
	if fake.owningSIGReturnsOnCall == nil {
		fake.owningSIGReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.owningSIGReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) ParticipatingSIGs() []string {
	fake.participatingSIGsMutex.Lock()
	ret, specificReturn := fake.participatingSIGsReturnsOnCall[len(fake.participatingSIGsArgsForCall)]
	fake.participatingSIGsArgsForCall = append(fake.participatingSIGsArgsForCall, struct {
	}{})
	fake.recordInvocation("ParticipatingSIGs", []interface{}{})
	fake.participatingSIGsMutex.Unlock()
	if fake.ParticipatingSIGsStub != nil {
		return fake.ParticipatingSIGsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.participatingSIGsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ParticipatingSIGsCallCount() int {
	fake.participatingSIGsMutex.RLock()
	defer fake.participatingSIGsMutex.RUnlock()
	return len(fake.participatingSIGsArgsForCall)
}

func (fake *FakeKEP) ParticipatingSIGsReturns(result1 []string) {
	fake.ParticipatingSIGsStub = nil
	fake.participatingSIGsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ParticipatingSIGsReturnsOnCall(i int, result1 []string) {
	fake.ParticipatingSIGsStub = nil
	if fake.participatingSIGsReturnsOnCall == nil {
		fake.participatingSIGsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.participatingSIGsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Persist() error {
	fake.persistMutex.Lock()
	ret, specificReturn := fake.persistReturnsOnCall[len(fake.persistArgsForCall)]
	fake.persistArgsForCall = append(fake.persistArgsForCall, struct {
	}{})
	fake.recordInvocation("Persist", []interface{}{})
	fake.persistMutex.Unlock()
	if fake.PersistStub != nil {
		return fake.PersistStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.persistReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) PersistCallCount() int {
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	return len(fake.persistArgsForCall)
}

func (fake *FakeKEP) PersistReturns(result1 error) {
	fake.PersistStub = nil
	fake.persistReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeKEP) PersistReturnsOnCall(i int, result1 error) {
	fake.PersistStub = nil
	if fake.persistReturnsOnCall == nil {
		fake.persistReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.persistReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeKEP) Replaces() []string {
	fake.replacesMutex.Lock()
	ret, specificReturn := fake.replacesReturnsOnCall[len(fake.replacesArgsForCall)]
	fake.replacesArgsForCall = append(fake.replacesArgsForCall, struct {
	}{})
	fake.recordInvocation("Replaces", []interface{}{})
	fake.replacesMutex.Unlock()
	if fake.ReplacesStub != nil {
		return fake.ReplacesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.replacesReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ReplacesCallCount() int {
	fake.replacesMutex.RLock()
	defer fake.replacesMutex.RUnlock()
	return len(fake.replacesArgsForCall)
}

func (fake *FakeKEP) ReplacesReturns(result1 []string) {
	fake.ReplacesStub = nil
	fake.replacesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ReplacesReturnsOnCall(i int, result1 []string) {
	fake.ReplacesStub = nil
	if fake.replacesReturnsOnCall == nil {
		fake.replacesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.replacesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Reviewers() []string {
	fake.reviewersMutex.Lock()
	ret, specificReturn := fake.reviewersReturnsOnCall[len(fake.reviewersArgsForCall)]
	fake.reviewersArgsForCall = append(fake.reviewersArgsForCall, struct {
	}{})
	fake.recordInvocation("Reviewers", []interface{}{})
	fake.reviewersMutex.Unlock()
	if fake.ReviewersStub != nil {
		return fake.ReviewersStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.reviewersReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ReviewersCallCount() int {
	fake.reviewersMutex.RLock()
	defer fake.reviewersMutex.RUnlock()
	return len(fake.reviewersArgsForCall)
}

func (fake *FakeKEP) ReviewersReturns(result1 []string) {
	fake.ReviewersStub = nil
	fake.reviewersReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) ReviewersReturnsOnCall(i int, result1 []string) {
	fake.ReviewersStub = nil
	if fake.reviewersReturnsOnCall == nil {
		fake.reviewersReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.reviewersReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) SIGWide() bool {
	fake.sIGWideMutex.Lock()
	ret, specificReturn := fake.sIGWideReturnsOnCall[len(fake.sIGWideArgsForCall)]
	fake.sIGWideArgsForCall = append(fake.sIGWideArgsForCall, struct {
	}{})
	fake.recordInvocation("SIGWide", []interface{}{})
	fake.sIGWideMutex.Unlock()
	if fake.SIGWideStub != nil {
		return fake.SIGWideStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sIGWideReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) SIGWideCallCount() int {
	fake.sIGWideMutex.RLock()
	defer fake.sIGWideMutex.RUnlock()
	return len(fake.sIGWideArgsForCall)
}

func (fake *FakeKEP) SIGWideReturns(result1 bool) {
	fake.SIGWideStub = nil
	fake.sIGWideReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) SIGWideReturnsOnCall(i int, result1 bool) {
	fake.SIGWideStub = nil
	if fake.sIGWideReturnsOnCall == nil {
		fake.sIGWideReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.sIGWideReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeKEP) Sections() []string {
	fake.sectionsMutex.Lock()
	ret, specificReturn := fake.sectionsReturnsOnCall[len(fake.sectionsArgsForCall)]
	fake.sectionsArgsForCall = append(fake.sectionsArgsForCall, struct {
	}{})
	fake.recordInvocation("Sections", []interface{}{})
	fake.sectionsMutex.Unlock()
	if fake.SectionsStub != nil {
		return fake.SectionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sectionsReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) SectionsCallCount() int {
	fake.sectionsMutex.RLock()
	defer fake.sectionsMutex.RUnlock()
	return len(fake.sectionsArgsForCall)
}

func (fake *FakeKEP) SectionsReturns(result1 []string) {
	fake.SectionsStub = nil
	fake.sectionsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) SectionsReturnsOnCall(i int, result1 []string) {
	fake.SectionsStub = nil
	if fake.sectionsReturnsOnCall == nil {
		fake.sectionsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.sectionsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) SetState(arg1 states.Name) {
	fake.setStateMutex.Lock()
	fake.setStateArgsForCall = append(fake.setStateArgsForCall, struct {
		arg1 states.Name
	}{arg1})
	fake.recordInvocation("SetState", []interface{}{arg1})
	fake.setStateMutex.Unlock()
	if fake.SetStateStub != nil {
		fake.SetStateStub(arg1)
	}
}

func (fake *FakeKEP) SetStateCallCount() int {
	fake.setStateMutex.RLock()
	defer fake.setStateMutex.RUnlock()
	return len(fake.setStateArgsForCall)
}

func (fake *FakeKEP) SetStateArgsForCall(i int) states.Name {
	fake.setStateMutex.RLock()
	defer fake.setStateMutex.RUnlock()
	argsForCall := fake.setStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKEP) ShortID() int {
	fake.shortIDMutex.Lock()
	ret, specificReturn := fake.shortIDReturnsOnCall[len(fake.shortIDArgsForCall)]
	fake.shortIDArgsForCall = append(fake.shortIDArgsForCall, struct {
	}{})
	fake.recordInvocation("ShortID", []interface{}{})
	fake.shortIDMutex.Unlock()
	if fake.ShortIDStub != nil {
		return fake.ShortIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.shortIDReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) ShortIDCallCount() int {
	fake.shortIDMutex.RLock()
	defer fake.shortIDMutex.RUnlock()
	return len(fake.shortIDArgsForCall)
}

func (fake *FakeKEP) ShortIDReturns(result1 int) {
	fake.ShortIDStub = nil
	fake.shortIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeKEP) ShortIDReturnsOnCall(i int, result1 int) {
	fake.ShortIDStub = nil
	if fake.shortIDReturnsOnCall == nil {
		fake.shortIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.shortIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeKEP) State() states.Name {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if fake.StateStub != nil {
		return fake.StateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stateReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeKEP) StateReturns(result1 states.Name) {
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 states.Name
	}{result1}
}

func (fake *FakeKEP) StateReturnsOnCall(i int, result1 states.Name) {
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 states.Name
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 states.Name
	}{result1}
}

func (fake *FakeKEP) SupersededBy() []string {
	fake.supersededByMutex.Lock()
	ret, specificReturn := fake.supersededByReturnsOnCall[len(fake.supersededByArgsForCall)]
	fake.supersededByArgsForCall = append(fake.supersededByArgsForCall, struct {
	}{})
	fake.recordInvocation("SupersededBy", []interface{}{})
	fake.supersededByMutex.Unlock()
	if fake.SupersededByStub != nil {
		return fake.SupersededByStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.supersededByReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) SupersededByCallCount() int {
	fake.supersededByMutex.RLock()
	defer fake.supersededByMutex.RUnlock()
	return len(fake.supersededByArgsForCall)
}

func (fake *FakeKEP) SupersededByReturns(result1 []string) {
	fake.SupersededByStub = nil
	fake.supersededByReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) SupersededByReturnsOnCall(i int, result1 []string) {
	fake.SupersededByStub = nil
	if fake.supersededByReturnsOnCall == nil {
		fake.supersededByReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.supersededByReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeKEP) Title() string {
	fake.titleMutex.Lock()
	ret, specificReturn := fake.titleReturnsOnCall[len(fake.titleArgsForCall)]
	fake.titleArgsForCall = append(fake.titleArgsForCall, struct {
	}{})
	fake.recordInvocation("Title", []interface{}{})
	fake.titleMutex.Unlock()
	if fake.TitleStub != nil {
		return fake.TitleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.titleReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) TitleCallCount() int {
	fake.titleMutex.RLock()
	defer fake.titleMutex.RUnlock()
	return len(fake.titleArgsForCall)
}

func (fake *FakeKEP) TitleReturns(result1 string) {
	fake.TitleStub = nil
	fake.titleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) TitleReturnsOnCall(i int, result1 string) {
	fake.TitleStub = nil
	if fake.titleReturnsOnCall == nil {
		fake.titleReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.titleReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) UniqueID() string {
	fake.uniqueIDMutex.Lock()
	ret, specificReturn := fake.uniqueIDReturnsOnCall[len(fake.uniqueIDArgsForCall)]
	fake.uniqueIDArgsForCall = append(fake.uniqueIDArgsForCall, struct {
	}{})
	fake.recordInvocation("UniqueID", []interface{}{})
	fake.uniqueIDMutex.Unlock()
	if fake.UniqueIDStub != nil {
		return fake.UniqueIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.uniqueIDReturns
	return fakeReturns.result1
}

func (fake *FakeKEP) UniqueIDCallCount() int {
	fake.uniqueIDMutex.RLock()
	defer fake.uniqueIDMutex.RUnlock()
	return len(fake.uniqueIDArgsForCall)
}

func (fake *FakeKEP) UniqueIDReturns(result1 string) {
	fake.UniqueIDStub = nil
	fake.uniqueIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) UniqueIDReturnsOnCall(i int, result1 string) {
	fake.UniqueIDStub = nil
	if fake.uniqueIDReturnsOnCall == nil {
		fake.uniqueIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.uniqueIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeKEP) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addApproversMutex.RLock()
	defer fake.addApproversMutex.RUnlock()
	fake.addReviewersMutex.RLock()
	defer fake.addReviewersMutex.RUnlock()
	fake.addSectionsMutex.RLock()
	defer fake.addSectionsMutex.RUnlock()
	fake.affectedSubprojectsMutex.RLock()
	defer fake.affectedSubprojectsMutex.RUnlock()
	fake.approversMutex.RLock()
	defer fake.approversMutex.RUnlock()
	fake.authorsMutex.RLock()
	defer fake.authorsMutex.RUnlock()
	fake.contentDirMutex.RLock()
	defer fake.contentDirMutex.RUnlock()
	fake.createdMutex.RLock()
	defer fake.createdMutex.RUnlock()
	fake.developmentThemesMutex.RLock()
	defer fake.developmentThemesMutex.RUnlock()
	fake.editorsMutex.RLock()
	defer fake.editorsMutex.RUnlock()
	fake.kubernetesWideMutex.RLock()
	defer fake.kubernetesWideMutex.RUnlock()
	fake.lastUpdatedMutex.RLock()
	defer fake.lastUpdatedMutex.RUnlock()
	fake.owningSIGMutex.RLock()
	defer fake.owningSIGMutex.RUnlock()
	fake.participatingSIGsMutex.RLock()
	defer fake.participatingSIGsMutex.RUnlock()
	fake.persistMutex.RLock()
	defer fake.persistMutex.RUnlock()
	fake.replacesMutex.RLock()
	defer fake.replacesMutex.RUnlock()
	fake.reviewersMutex.RLock()
	defer fake.reviewersMutex.RUnlock()
	fake.sIGWideMutex.RLock()
	defer fake.sIGWideMutex.RUnlock()
	fake.sectionsMutex.RLock()
	defer fake.sectionsMutex.RUnlock()
	fake.setStateMutex.RLock()
	defer fake.setStateMutex.RUnlock()
	fake.shortIDMutex.RLock()
	defer fake.shortIDMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.supersededByMutex.RLock()
	defer fake.supersededByMutex.RUnlock()
	fake.titleMutex.RLock()
	defer fake.titleMutex.RUnlock()
	fake.uniqueIDMutex.RLock()
	defer fake.uniqueIDMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKEP) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ metadata.KEP = new(FakeKEP)
